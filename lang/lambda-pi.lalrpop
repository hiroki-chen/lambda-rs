//! This `lalrpop` file defines the syntax of a domain specific language which is used to
//! generate a parser that can be used to do lambda calculus interpretation.

grammar;

use crate::ast::*;

match {
    r"(?i)(type)",
    r"(?i)(eval)",
    r"i8",
    r"i16",
    r"i32",
    r"i64",
    r"u8",
    r"u16",
    r"u32",
    r"u64",
    r"f32",
    r"f64",
    r"U",
    r"(bool)|(boolean)",
    r"(str)|([sS]tring)",
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Identifier,
} else {
    _,
}

#[inline]
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Cmd: Statement = {
    <t: Type> <id: Identifier> "::" <e: Ast> ";" =>
        Statement::Declare(id.to_string(), *e),
    <e: Eval> <what: Ast> ";" =>
        Statement::Eval(*what),
}

pub Ast: Box<AstNode> = {
    r"U" => Box::new(AstNode::Universe),
}

// type.
Type: String = <s:r"(?i)(type)"> => s.into();
// eval
Eval: String = <s:r"(?i)(eval)"> => s.into();
